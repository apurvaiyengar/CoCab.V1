import dash
from dash import dcc, html, Input, Output, State
import pandas as pd
import base64
import subprocess
import signal
import dash_bootstrap_components as dbc
import dash_ag_grid as dag

# Create a Dash application instance
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Global variable to keep track of the data collection process
data_collection_process = None

# Define the layout of the Dash app
app.layout = html.Div(
    [
    html.H1("CoCab Dashboard"),
    html.Button('Start', id='start-button', n_clicks=0),
    html.Button('Stop', id='stop-button', n_clicks=0),
    html.Hr(),
    dcc.Input(id='file-name-input', type='text', placeholder='Enter CSV file name'),
    html.Button('Download CSV', id='download-button', n_clicks=0),
    dcc.Download(id='download-data'),
    dag.AgGrid(           
        className="ag-theme-alpine-dark",
        )])

@app.callback(
    Output('download-data', 'data'),
    Input('download-button', 'n_clicks'),
    State('file-name-input', 'value')
)
def download_csv(n_clicks, file_name):
    """
    Callback to handle CSV file download request.
    If the download button is clicked and a file name is provided,
    the CSV data is read and converted to a downloadable format.
    """
    if n_clicks > 0 and file_name:
        try:
            # Read the dummy CSV file generated by the data collector script
            df = pd.read_csv('/home/pi/CoCab.V1/data_container.csv')
            # Convert DataFrame to a CSV formatted string
            csv_string = df.to_csv(index=False)
            # Encode the CSV string in base64 to prepare for download
            b64 = base64.b64encode(csv_string.encode()).decode()
            return dict(content=b64, filename=f'{file_name}.csv')
        except Exception as e:
            print(f"Error generating CSV: {e}")
            return None
    return None

@app.callback(
    Output('start-button', 'children'),
    Input('start-button', 'n_clicks')
)
def start_data_collection(n_clicks):
    """
    Callback to start the data collection process.
    Runs the data_collector.py script as a subprocess if not already running.
    """
    global data_collection_process
    if n_clicks > 0:
        # Check if the process is not already running or has terminated
        if data_collection_process is None or data_collection_process.poll() is not None:
            # Start the data collection script as a subprocess
            data_collection_process = subprocess.Popen(['python3', '/home/pi/CoCab.V1/combov5.py'])
            return 'Starting up...'
        return 'CoCab running'
    return 'Ready to start'

@app.callback(
    Output('stop-button', 'children'),
    Input('stop-button', 'n_clicks')
)
def stop_data_collection(n_clicks):
    """
    Callback to stop the data collection process.
    Sends a SIGINT signal to terminate the data collector script.
    """
    global data_collection_process
    if n_clicks > 0 and data_collection_process is not None:
        try:
            # Send SIGINT signal to the data collection process (equivalent to Ctrl+C)
            data_collection_process.send_signal(signal.SIGINT)
            # Wait for the process to terminate gracefully
            data_collection_process.wait()
            data_collection_process = None
            return 'Stopped'
        except Exception as e:
            print(f"Error stopping: {e}")
            return 'Error Stopping'
    return 'Stop'

if __name__ == '__main__':
    # Run the Dash app server
    app.run_server(host='0.0.0.0', port=8050, debug=True)
